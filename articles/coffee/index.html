<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Blag: Understanding the Elm Architecture</title>
    <link rel="stylesheet" href="/stylesheets/main.css">
    <link rel="stylesheet" href="/stylesheets/coderay.css">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
  </head>
  <body class="regular">
    <div id="main">
      <ul id="menu">
        <li><a href="/articles/">Articles</a></li>
        <!-- <li><a href="/posts/">Posts</a></li> -->
      </ul>
      <div id="content">
        <div class="block"><h1>Understanding the Elm Architecture</h1></div>


<div class="block p gamma">
 <p>Elm is a pure, functional language with managed effects. This means that none of your Elm code will ever
directly cause effects. Here are some useful effects:</p>
</div>
<div class="block ul beta">
 <ul>
   <li>Updating your application's state</li>
   <li>Rendering and updating the DOM</li>
   <li>Making HTTP calls</li>
   <li>Getting the current time (not technically an effect, but still impure)</li>
 </ul>
</div>
<div class="block p gamma">
 <p>As you can imagine, the vast majority of programs need to cause effects to be considered useful. Elm allows you
to tell it to cause effects for you: You give it a description of the effects you'd like to cause, and
Elm does it for you. A clear separation exists: Your code, the "inside world", and everything else, the
"outside world".</p>
</div>
<div class="block html_element delta">
 <div class="block">
  <img src="/images/tea-1.svg" />
</div>
</div>
<div class="block p beta">
 <p>The Elm runtime is your link to the outside world: It is responsible for running your code, and it is the only
place where data crosses the boundary between the inside and outside worlds. Apart from this link to the
runtime, your code is completely isolated.</p>
</div>
<div class="block p gamma">
 <p>The runtime starts your program by calling a single function called <code>main</code>. In a browser-based GUI application,
this function will call one of several possible functions to initialize it. The one I will use as an example
is <code>Html.program</code>, as it embodies the "Elm Architecture" well without getting too complex:</p>
</div>
<div class="block codeblock gamma">
 <pre><code class="elm">program : { init : (model, Cmd msg)
          , update : msg -&gt; model -&gt; (model, Cmd msg)
          , subscriptions : model -&gt; Sub msg
          , view : model -&gt; Html msg }
          -&gt; Program Never model msg </code></pre>
</div>
<div class="block p alpha">
 <p>Specialized to the actual types most programs use by convention:</p>
</div>
<div class="block codeblock beta">
 <pre><code class="elm">program : { init : (Model, Cmd Msg)
          , update : Msg -&gt; Model -&gt; (Model, Cmd Msg)
          , subscriptions : Model -&gt; Sub Msg
          , view : Model -&gt; Html Msg }
          -&gt; Program Never Model Msg </code></pre>
</div>
<div class="block p beta">
 <p>You define 4 lifecycle functions and give them to <code>Html.program</code> as a record, and it will call these functions
at various points in your program's lifetime</p>
</div>
<div class="block html_element delta">
 <div class="block">
  <img src="/images/tea-2.svg" />
</div>
</div>
<div class="block header delta">
 <h2 id="application-state-the-model">Application state (the model)</h2>
</div>
<div class="block p gamma">
 <p>Your code does not explicitly maintain any state, the inside world is stateless. The runtime is responsible
for maintaining state in the outside world, where this is allowed.</p>
</div>
<div class="block p beta">
 <p>The state is contained in a single data structure, usually with the type <code>Model</code>:</p>
</div>
<div class="block codeblock delta">
 <pre><code class="elm">type TodoItem = {
    title : String
  , done : Bool
  }

type alias Model = List TodoItem </code></pre>
</div>
<div class="block p delta">
 <p>When your program starts, the runtime will call <code>init</code> which returns the initial state:</p>
</div>
<div class="block codeblock alpha">
 <pre><code class="elm">init : (Model, Cmd Msg)
init = ([TodoItem &quot;Procrastinate&quot; True, TodoItem &quot;Finish writing this article&quot; False, TodoItem &quot;Profit&quot; False], Cmd.none) </code></pre>
</div>
<div class="block p beta">
 <p><code>init</code> returns a tuple of <code>(Model, Cmd Msg)</code>. Ignore the <code>Cmd Msg</code> for now. The <code>Model</code> is returned by <code>init</code>
to the runtime, which saves this as the initial state of the application.</p>
</div>
<div class="block html_element alpha">
 <div class="block">
  <img src="/images/tea-3.svg" />
</div>
</div>
<div class="block p gamma">
 <p>After initialization, the runtime listens for events in the outside world. Your program defines a list of events
that can happen:</p>
</div>
<div class="block codeblock delta">
 <pre><code class="elm">type Msg
  = NewItem Item
  | RemoveItem Item
  | CheckItem Item
  | UncheckItem Item </code></pre>
</div>
<div class="block p gamma">
 <p>When one of these events happen, the runtime will call your <code>update</code> function and pass it, along with the current
state:</p>
</div>
<div class="block codeblock beta">
 <pre><code class="elm">update : Msg -&gt; Model -&gt; (Model, Cmd Msg)
update msg model =
  case msg of
    NewItem item -&gt;
      (item :: items, Cmd.none)
    RemoveItem item -&gt;
      (List.filter (\i -&gt; i == item) items, Cmd.none)
    CheckItem item -&gt;
      (List.map (\i -&gt; if i == item then {i | done = True} else i) items, Cmd.none)
    UncheckItem item -&gt;
      (List.map (\i -&gt; if i == item then {i | done = False} else i) items, Cmd.none) </code></pre>
</div>
<div class="block p alpha">
 <p>Typically, <code>update</code> will pattern match on the event, the <code>Msg</code>, to see which type of event it is and then do something
different for each event. Of course, <em>nothing is changed</em> inside <code>update</code> as it runs in the inside world where mutation
is forbidden. It will return a <em>new</em> value as part of the tuple <code>(Model, Cmd Msg)</code>. The runtime will receive this new
<code>Model</code> across the boundary and store it as the new state in the outside world.</p>
</div>
<div class="block html_element gamma">
 <div class="block">
  <img src="/images/tea-4.svg" />
</div>
</div>
<div class="block p beta">
 <p>You can imagine the runtime working something like this:</p>
</div>
<div class="block codeblock gamma">
 <pre><code class="javascript"><span class="comment">// Initialize the state by calling `init`</span>
<span class="keyword">var</span> state = YourApp.init()[<span class="integer">0</span>];

onEvent(<span class="keyword">function</span>(event){
  <span class="comment">// When an event happens, run `update` and save the new state</span>
  state = YourApp.update(event, state)[<span class="integer">0</span>];
}); </code></pre>
</div>
<div class="block p beta">
 <p>The runtime is basically an event loop, and your <code>update</code> function is the callback.</p>
</div>
<div class="block header delta">
 <h2 id="rendering-to-the-dom-the-view">Rendering to the DOM (the view)</h2>
</div>
<div class="block p beta">
 <p>It is not possible to interact with the DOM from the inside world. None of your Elm code can see the DOM, as it exists
only in the outside world. As with your application state, it is the runtime that's responsible for maintaining a
representation of your state in the DOM.</p>
</div>
<div class="block p beta">
 <p>After it calls <code>init</code>, and after each call to <code>update</code>, the runtime will call your <code>view</code> function, passing it the
new state it's just received. <code>view</code> will then return a description of how you would like for the DOM to look, in
the form of a <code>Html Msg</code> value.</p>
</div>
<div class="block codeblock gamma">
 <pre><code class="elm">view : Model -&gt; Html Msg
view model =
  todoItems model

todoItems : List TodoItem -&gt; Html Msg
todoItems items =
  ul [] (List.map todoItem items)

todoItem : TodoItem -&gt; Html Msg
todoItem item =
  li [classList [(&quot;checked&quot;, item.done)]] [text item.title] </code></pre>
</div>
<div class="block p beta">
 <p>An <code>Html Msg</code> represents a DOM node with attributes and zero or more child nodes. In the example, the list of
<code>TodoItem</code>s is turned into a <code>Html Msg</code> tree representing this HTML:</p>
</div>
<div class="block codeblock beta">
 <pre><code class="html"><span class="tag">&lt;ul&gt;</span>
  <span class="tag">&lt;li</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">checked</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Procrastinate<span class="tag">&lt;/li&gt;</span>
  <span class="tag">&lt;li&gt;</span>Finish writing this article<span class="tag">&lt;/li&gt;</span>
  <span class="tag">&lt;li&gt;</span>Profit<span class="tag">&lt;/li&gt;</span>
<span class="tag">&lt;/ul&gt;</span> </code></pre>
</div>
<div class="block p delta">
 <p>The runtime will receive this description across the boundary and apply it to the actual DOM in the outside world.
This makes sure the state of the DOM always reflects the current state of the application.</p>
</div>
<div class="block html_element beta">
 <div class="block">
  <img src="/images/tea-5.svg" />
</div>
</div>
<div class="block p delta">
 <p>The runtime now looks more like this:</p>
</div>
<div class="block codeblock beta">
 <pre><code class="javascript"><span class="comment">// Initialize the state by calling `init`</span>
<span class="keyword">var</span> state = YourApp.init()[<span class="integer">0</span>];

<span class="comment">// The root node of our application's view</span>
<span class="keyword">var</span> root = document.body;

<span class="comment">// Render the initial state to the DOM</span>
root.innerHTML = renderDOM(YourApp.view(state));

onEvent(<span class="keyword">function</span>(event){
  <span class="comment">// When an event happens, run `update` and save the new state</span>
  state = YourApp.update(event, state)[<span class="integer">0</span>];

  <span class="comment">// Call `view` with the new state and apply the result to the DOM</span>
  root.innerHTML = renderDOM(YourApp.view(state));
}); </code></pre>
</div>
<div class="block header gamma">
 <h2 id="where-do-events-come-from">Where do events come from?</h2>
</div>
<div class="block p alpha">
 <p>Events do not come from nothing. Nothing happens unless you instruct the runtime to do something that may
result in events happening. There are 3 sources of events:</p>
</div>
<div class="block ul alpha">
 <ul>
   <li>DOM events</li>
   <li>Commands</li>
   <li>Subscriptions</li>
 </ul>
</div>
<div class="block header alpha">
 <h2 id="dom-events">DOM events</h2>
</div>
<div class="block p gamma">
 <p>In the node tree returned by your <code>view</code> function, you may include descriptions of DOM event handlers. When the
runtime sees these it will attach the necessary handlers to the DOM.</p>
</div>
<div class="block codeblock alpha">
 <pre><code class="elm">  todoItem : TodoItem -&gt; Html Msg
  todoItem item =
    li [classList [(&quot;checked&quot;, item.done)], onClick (CheckItem item)] [text item.title] </code></pre>
</div>
<div class="block p alpha">
 <p>The example has been changed to add an <code>onClick</code> handler to the virtual DOM node. When this is returned from
<code>view</code>, the runtime will apply it to the DOM:</p>
</div>
<div class="block codeblock gamma">
 <pre><code class="html"><span class="tag">&lt;ul&gt;</span>
  <span class="tag">&lt;li</span> <span class="attribute-name">onClick</span>=<span class="string"><span class="delimiter">&quot;</span>onEvent(CheckItem(state[<span class="integer">0</span>]))<span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">checked</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Procrastinate<span class="tag">&lt;/li&gt;</span>
  <span class="tag">&lt;li</span> <span class="attribute-name">onClick</span>=<span class="string"><span class="delimiter">&quot;</span>onEvent(CheckItem(state[<span class="integer">1</span>]))<span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Finish writing this article<span class="tag">&lt;/li&gt;</span>
  <span class="tag">&lt;li</span> <span class="attribute-name">onClick</span>=<span class="string"><span class="delimiter">&quot;</span>onEvent(CheckItem(state[<span class="integer">2</span>]))<span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Profit<span class="tag">&lt;/li&gt;</span>
<span class="tag">&lt;/ul&gt;</span> </code></pre>
</div>
<div class="block p delta">
 <p>The <code>Msg</code> part of <code>Html Msg</code> means that events of type <code>Msg</code> (and only this type) can originate from this node.
When a DOM event occurs, the runtime will translate this to one of the events you've listed as part of the <code>Msg</code>
type and call your <code>update</code> and <code>view</code> functions.</p>
</div>
<div class="block header beta">
 <h2 id="commands">Commands</h2>
</div>
<div class="block p delta">
 <p>Commands are structures of the type <code>Cmd</code> that instruct the runtime to perform effects. A good example is making
an HTTP call:</p>
</div>
<div class="block codeblock beta">
 <pre><code class="elm">type Msg =
  ...
  | TodoItemsResponse (Result Http.Error (List TodoItem))

fetchTodoItems : Cmd Msg
fetchTodoItems =
  Http.get &quot;/todo-items.json&quot; todoItemsDecoder
    |&gt; Http.send TodoItemsResponse </code></pre>
</div>
<div class="block p beta">
 <p>Note the new event type that's been added to <code>Msg</code> and the use of <code>TodoItemsResponse</code> as an argument to <code>Http.send</code>.
The resulting <code>Cmd</code> will include information on how to construct a <code>Msg</code> that will be passed to your <code>update</code>
function. It is essentially a callback: You are only <em>describing</em> an effect that will happen at some point in the
future, and when it happens the runtime will notice this and call your <code>update</code> with the result:</p>
</div>
<div class="block codeblock alpha">
 <pre><code class="elm">update msg model =
  case msg of
    ...
    TodoItemsResponse result -&gt;
      case result of
        Err error -&gt;
          -- Ignore the error and just return the same model
          (model, Cmd.none)
        Ok items -&gt;
          -- Update the model to be the new list of TodoItems
          (items, Cmd.none) </code></pre>
</div>
<div class="block p alpha">
 <p><code>Html.program</code>, as the mediator between the inside and the outside world, specifies 2 functions that may return a
<code>Cmd</code>:</p>
</div>
<div class="block codeblock alpha">
 <pre><code class="elm">program : { init : (Model, Cmd Msg)
          , update : Msg -&gt; Model -&gt; (Model, Cmd Msg)
          , subscriptions : Model -&gt; Sub Msg
          , view : Model -&gt; Html Msg }
          -&gt; Program Never Model Msg </code></pre>
</div>
<div class="block p beta">
 <p>Both <code>init</code> and <code>update</code> return a tuple of <code>(Model, Cmd Msg)</code>. Most of the time, you will simply return <code>Cmd.none</code>,
which means "do nothing". But if you <em>do</em> want to cause an effect, this is where you must return the <code>Cmd</code>
representing your effect. You can create as many <code>Cmd</code>s as you want in the inside world, but unless you give then
to the runtime as a return value of these two functions, nothing happens.</p>
</div>
<div class="block p gamma">
 <p>The following <code>init</code> sets the initial state to be an empty list and returns a <code>Cmd</code> which
instructs the runtime to try and fetch the actual <code>TodoItem</code> list from the server:</p>
</div>
<div class="block codeblock delta">
 <pre><code class="elm">init : (Model, Cmd Msg)
init = ([], fetchTodoItems) </code></pre>
</div>
<div class="block p delta">
 <p>When the server responds, the runtime will call <code>update</code> with the <code>TodoItemsResponse</code> which will update the model
if the response was successful.</p>
</div>
<div class="block html_element delta">
 <div class="block">
  <img src="/images/tea-6.svg" />
</div>
</div>
<div class="block p alpha">
 <p>The pretend-runtime updated to take commands into account:</p>
</div>
<div class="block codeblock beta">
 <pre><code class="javascript"><span class="comment">// Initialize the state by calling `init`</span>
<span class="keyword">var</span> [state, cmd] = YourApp.init();

<span class="comment">// If a command was returned, execute it asynchronously</span>
<span class="keyword">if</span> (cmd) executeCmd(cmd, <span class="keyword">function</span>(res){ onEvent(cmd.createMsg(res)); });

<span class="comment">// The root node of our application's view</span>
<span class="keyword">var</span> root = document.body;

<span class="comment">// Render the initial state to the DOM</span>
root.innerHTML = renderDOM(YourApp.view(state));

onEvent(<span class="keyword">function</span>(event){
  <span class="comment">// When an event happens, run `update` and save the new state</span>
  [state, cmd] = YourApp.update(event, state);

  <span class="comment">// If a command was returned, execute it asynchronously</span>
  <span class="keyword">if</span> (cmd) executeCmd(cmd, <span class="keyword">function</span>(res){ onEvent(cmd.createMsg(res)); });

  <span class="comment">// Call `view` with the new state and apply the result to the DOM</span>
  root.innerHTML = renderDOM(YourApp.view(state));
}); </code></pre>
</div>
<div class="block header gamma">
 <h2 id="subscriptions">Subscriptions</h2>
</div>
<div class="block p gamma">
 <p>Subscriptions are for repeating events. Some examples are WebSocket connections that represent a stream of
messages, or a "tick" event that occurs every second to update the inside world's time.</p>
</div>
<div class="block p gamma">
 <p>Subscriptions are represented by the <code>Sub Msg</code> type, and there is only 1 way to tell the runtime about your
interest in them: The <code>subscriptions</code> function executed by <code>Html.program</code>, which takes a <code>Model</code> and returns
a <code>Sub Msg</code>.</p>
</div>
<div class="block p beta">
 <p>A simple example is <code>Time.every</code>, which returns a <code>Sub Msg</code> that results in an event containing the current
time every second:</p>
</div>
<div class="block codeblock gamma">
 <pre><code class="elm">type Msg =
  ...
  | Tick Time

update msg model =
  case msg of
    Tick time -&gt;
      -- Do something with `time` here

subscriptions : Model -&gt; Sub Msg
subscriptions model =
  Time.every Time.second Tick </code></pre>
</div>
<div class="block p beta">
 <p>The <code>subscriptions</code> function is called whenever the <code>Model</code> changes. If you're not an experienced functional
programmer, this may seem weird and even dangerous to you. But as you know, this function runs in the inside
world where everything is safe and pure: All it does is return a <em>description</em> of the repeating events you're
interested in. The runtime will check if that description has changed since the last time and reconcile its
internal state in the outside world if necessary.</p>
</div>
<div class="block html_element alpha">
 <div class="block">
  <img src="/images/tea-7.svg" />
</div>
</div>

      </div>
    </div>
  </body>
</html>
